---
title: "Rozpoznawanie zależności pakietu NuGet | Dokumentacja firmy Microsoft"
author: kraigb
ms.author: kraigb
manager: ghogen
ms.date: 8/14/2017
ms.topic: article
ms.prod: nuget
ms.technology: 
ms.assetid: 1d530a72-3486-4a0d-b6fb-017524616f91
description: "Szczegółowe informacje na temat procesu za pomocą którego rozwiązany i zainstalowane w obu NuGet zależności pakietu NuGet 2.x i NuGet 3.x+."
keywords: "Zależności pakietów NuGet, przechowywanie wersji NuGet, wersje zależności, wykres wersji, rozdzielczość wersji, przechodnie przywracania"
ms.reviewer:
- karann-msft
- unniravindranathan
ms.openlocfilehash: 251ae6944cc0010f596c9b3daf95c318595a5c4d
ms.sourcegitcommit: a40c1c1cc05a46410f317a72f695ad1d80f39fa2
ms.translationtype: MT
ms.contentlocale: pl-PL
ms.lasthandoff: 01/05/2018
---
# <a name="how-nuget-resolves-package-dependencies"></a><span data-ttu-id="a3d1c-104">Jak NuGet jest rozpoznawany jako zależności pakietów</span><span class="sxs-lookup"><span data-stu-id="a3d1c-104">How NuGet resolves package dependencies</span></span>

<span data-ttu-id="a3d1c-105">Dowolnej chwili pakiet jest zainstalowany lub ponownej instalacji, w tym instalowane jako część [przywrócić](../consume-packages/package-restore.md) procesu NuGet instaluje wszystkie dodatkowe pakiety, od których zależy ten pierwszy pakietu.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-105">Any time a package is installed or reinstalled, which includes being installed as part of a [restore](../consume-packages/package-restore.md) process, NuGet also installs any additional packages on which that first package depends.</span></span>

<span data-ttu-id="a3d1c-106">Te zależności natychmiastowego następnie również zainstalować zależności na ich własnych, które mogą w dalszym dowolnego głębokość.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-106">Those immediate dependencies might then also have dependencies on their own, which can continue to an arbitrary depth.</span></span> <span data-ttu-id="a3d1c-107">Daje to tak zwany *wykresu zależności* , który opisuje relacje między pakietami są wszystkie poziomy.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-107">This produces what's called a *dependency graph* that describes the relationships between packages are all levels.</span></span>

<span data-ttu-id="a3d1c-108">Jeśli tego samego zależności wielu pakietów, następnie ten sam identyfikator pakietu może występować na wykresie wiele razy potencjalnie z ograniczeniami innej wersji.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-108">When multiple packages have the same dependency, then the same package ID can appear in the graph multiple times, potentially with different version constraints.</span></span> <span data-ttu-id="a3d1c-109">Jednak tylko jedna wersja danego pakietu może służyć w projekcie, dlatego należy wybrać NuGet, która wersja jest można użyć.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-109">However, only one version of a given package can be used in a project, so NuGet must choose which version is be used.</span></span> <span data-ttu-id="a3d1c-110">Dokładne proces zależy od używany format odwołanie do pakietu.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-110">The exact process depends on the package reference format being used.</span></span>

<span data-ttu-id="a3d1c-111">W tym temacie:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-111">In this topic:</span></span>
- [<span data-ttu-id="a3d1c-112">Rozpoznawanie zależności z PackageReference i project.json</span><span class="sxs-lookup"><span data-stu-id="a3d1c-112">Dependency resolution with PackageReference and project.json</span></span>](#dependency-resolution-with-packagereference-and-projectjson)
- [<span data-ttu-id="a3d1c-113">Rozpoznawanie zależności z pliku packages.config</span><span class="sxs-lookup"><span data-stu-id="a3d1c-113">Dependency resolution with packages.config</span></span>](#dependency-resolution-with-packagesconfig)
- <span data-ttu-id="a3d1c-114">[Z wyjątkiem odwołania](#excluding-references), jest to konieczne, jeśli występuje konflikt między zależność określonych w jednym projekcie i zestawu, który jest tworzony przez inny.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-114">[Excluding references](#excluding-references), which is necessary when there's a conflict between a dependency specified in one project and an assembly that's produced by another.</span></span>
- [<span data-ttu-id="a3d1c-115">Instalowanie aktualizacji zależności w pakiecie</span><span class="sxs-lookup"><span data-stu-id="a3d1c-115">Dependency updates during package install</span></span>](#dependency-updates-during-package-install)
- [<span data-ttu-id="a3d1c-116">Rozwiązywanie błędów niezgodne pakietu</span><span class="sxs-lookup"><span data-stu-id="a3d1c-116">Resolving incompatible package errors</span></span>](#resolving-incompatible-package-errors)

## <a name="dependency-resolution-with-packagereference-and-projectjson"></a><span data-ttu-id="a3d1c-117">Rozpoznawanie zależności z PackageReference i project.json</span><span class="sxs-lookup"><span data-stu-id="a3d1c-117">Dependency resolution with PackageReference and project.json</span></span>

<span data-ttu-id="a3d1c-118">Podczas instalowania pakietów do projektów przy użyciu PackageReference lub `project.json` formatów, NuGet dodaje odwołania do wykres prostych pakietu odpowiedniego pliku i pozwala rozwiązać konflikty wcześniejsze.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-118">When installing packages into projects using the PackageReference or `project.json` formats, NuGet adds references to a flat package graph in the appropriate file and resolves conflicts ahead of time.</span></span> <span data-ttu-id="a3d1c-119">Ten proces jest nazywany *przechodnie przywracania*.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-119">This process is referred to as *transitive restore*.</span></span> <span data-ttu-id="a3d1c-120">Ponowne zainstalowanie lub przywracanie pakietów następnie jest procesem pobierania pakietów wymienionych na wykresie, co powoduje szybsze i bardziej przewidywalne kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-120">Reinstalling or restoring packages is then a process of downloading the packages listed in the graph, resulting in faster and more predictable builds.</span></span> <span data-ttu-id="a3d1c-121">Można również wykorzystać (przestawne) wersji symboli wieloznacznych, takich jak 2.8. \*, unikając kosztowne i błąd wywołania podatne `nuget update` na komputerach klienckich i serwerach kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-121">You can also take advantage of wildcard (floating) versions, such as 2.8.\*, avoiding expensive and error prone calls to `nuget update` on the client machines and build servers.</span></span>

<span data-ttu-id="a3d1c-122">Po uruchomieniu procesu przywracania NuGet przed kompilacji go najpierw rozpoznaje zależności w pamięci, a następnie zapisuje wynikowego wykresu w pliku o nazwie `project.assets.json` w `obj` folderu projektu przy użyciu PackageReference lub w pliku o nazwie `project.lock.json` obok `project.json`.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-122">When the NuGet restore process runs prior to a build, it resolves dependencies first in memory, then writes the resulting graph to a file called `project.assets.json` in the `obj` folder of a project using PackageReference, or in a file named `project.lock.json` alongside `project.json`.</span></span> <span data-ttu-id="a3d1c-123">Następnie MSBuild odczytuje ten plik i przekształca ją w zestawie folderów, gdzie można znaleźć potencjalnych odwołania, a następnie dodanie ich do drzewa projektu w pamięci.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-123">MSBuild then reads this file and translates it into a set of folders where potential references can be found, and then adds them to the project tree in memory.</span></span>

<span data-ttu-id="a3d1c-124">Plik blokady jest tymczasowe i nie powinno być dodane do kontroli źródła.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-124">The lock file is temporary and should not be added to source control.</span></span> <span data-ttu-id="a3d1c-125">Ta opcja jest wyświetlana domyślnie zarówno `.gitignore` i `.tfignore`.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-125">It's listed by default in both `.gitignore` and `.tfignore`.</span></span> <span data-ttu-id="a3d1c-126">Zobacz [pakietów i kontroli źródła](Packages-and-Source-Control.md).</span><span class="sxs-lookup"><span data-stu-id="a3d1c-126">See [Packages and source control](Packages-and-Source-Control.md).</span></span>

### <a name="dependency-resolution-rules"></a><span data-ttu-id="a3d1c-127">Zasady rozpoznawania zależności</span><span class="sxs-lookup"><span data-stu-id="a3d1c-127">Dependency resolution rules</span></span>

<span data-ttu-id="a3d1c-128">Przywracanie przechodnie stosuje cztery główne zasady można rozpoznać zależności: najniższa odpowiedniej wersji, wersje przestawne najbliższej wins i cousin zależności.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-128">Transitive restore applies four main rules to resolve dependencies: lowest applicable version, floating versions, nearest-wins, and cousin dependencies.</span></span>

<a name="lowest-applicable-version"></a>

#### <a name="lowest-applicable-version"></a><span data-ttu-id="a3d1c-129">Najniższa wersja dotyczy</span><span class="sxs-lookup"><span data-stu-id="a3d1c-129">Lowest applicable version</span></span>

<span data-ttu-id="a3d1c-130">Najniższa reguła dotyczy wersji przywraca Najniższa wersja możliwe pakietu zgodnie z jego zależności.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-130">The lowest applicable version rule restores the lowest possible version of a package as defined by its dependencies.</span></span> <span data-ttu-id="a3d1c-131">Ma również zastosowanie do zależności w bibliotece klas programu lub aplikacji, chyba że zadeklarowany jako [przestawne](#floating-versions).</span><span class="sxs-lookup"><span data-stu-id="a3d1c-131">It also applies to dependencies on the application or the class library unless declared as [floating](#floating-versions).</span></span>

<span data-ttu-id="a3d1c-132">Na poniższej ilustracji na przykład 1.0 beta jest uznawane za niższa niż 1.0, wybierze NuGet w wersji 1.0:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-132">In the following figure, for example, 1.0-beta is considered lower than 1.0 so NuGet chooses the 1.0 version:</span></span>

![Wybieranie Najniższa wersja dotyczy](media/projectJson-dependency-1.png)

<span data-ttu-id="a3d1c-134">W następnej ilustracji wersji 2.1 nie jest dostępne w źródle danych, ale ponieważ jest ograniczenie wersji > = Dalej Najniższa wersja, można go znaleźć, w tym przypadku 2.2 2.1 pobrania NuGet:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-134">In the next figure, version 2.1 is not available on the feed but because the version constraint is >= 2.1 NuGet picks the next lowest version it can find, in this case 2.2:</span></span>

![Wybór następnego Najniższa wersja dostępne w źródle danych](media/projectJson-dependency-2.png)

<span data-ttu-id="a3d1c-136">Aplikacja określa numer wersji dokładne, takie jak 1.2, który nie jest dostępne w źródle danych, NuGet nie powiedzie się z powodu błędu podczas próby zainstalowania lub przywracanie pakietu:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-136">When an application specifies an exact version number, such as 1.2, that is not available on the feed, NuGet fails with an error when attempting to install or restore the package:</span></span>

![NuGet generuje błąd, gdy nie będzie dostępna wersja pakietu dokładnego](media/projectJson-dependency-3.png)

<a name="floating-versions"></a>

#### <a name="floating-wildcard-versions"></a><span data-ttu-id="a3d1c-138">Liczby zmiennoprzecinkowe (symbol wieloznaczny) wersji</span><span class="sxs-lookup"><span data-stu-id="a3d1c-138">Floating (wildcard) versions</span></span>

<span data-ttu-id="a3d1c-139">Wersja zależności zmiennoprzecinkową lub symbol wieloznaczny jest określany za pomocą \* symbolu wieloznacznego w wersji 6.0.\*.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-139">A floating or wildcard dependency version is specified with the \* wildcard, as with 6.0.\*.</span></span> <span data-ttu-id="a3d1c-140">Ta wersja specyfikacji mówi, "Korzystanie z najnowszej wersji 6.0.x;" 4.\* oznacza "używać najnowszej wersji 4.x."</span><span class="sxs-lookup"><span data-stu-id="a3d1c-140">This version specification says "use the latest 6.0.x version"; 4.\* means "use the latest 4.x version."</span></span> <span data-ttu-id="a3d1c-141">Przy użyciu symboli wieloznacznych umożliwia pakiet zależności, aby kontynuować, zmieniające się bez konieczności zmiany aplikacja odbierająca komunikaty (lub pakietu).</span><span class="sxs-lookup"><span data-stu-id="a3d1c-141">Using a wildcard allows a dependency package to continue evolving without requiring a change to the consuming application (or package).</span></span>

<span data-ttu-id="a3d1c-142">Korzystając z symbolem wieloznacznym, NuGet rozpoznaje najwyższa wersja pakietu, która odpowiada wzorcowi wersji, na przykład w wersji 6.0. \* pobiera najwyższa wersja pakietu, który rozpoczyna się od 6.0:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-142">When using a wildcard, NuGet resolves the highest version of a package that matches the version pattern, for example 6.0.\* gets the highest version of a package that starts with 6.0:</span></span>

![Wybieranie wersji 6.0.1 podczas przestawne w wersji 6.0. * jest wymagane](media/projectJson-dependency-4.png)

> [!Note]
> <span data-ttu-id="a3d1c-144">Aby uzyskać informacje na zachowanie symboli wieloznacznych i wersje wstępne, zobacz [wersji pakietu](../reference/package-versioning.md#version-ranges-and-wildcards).</span><span class="sxs-lookup"><span data-stu-id="a3d1c-144">For information on the behavior of wildcards and pre-release versions, see [Package versioning](../reference/package-versioning.md#version-ranges-and-wildcards).</span></span>


<a name="nearest-wins"></a>

#### <a name="nearest-wins"></a><span data-ttu-id="a3d1c-145">Najbliższej wins</span><span class="sxs-lookup"><span data-stu-id="a3d1c-145">Nearest wins</span></span>

<span data-ttu-id="a3d1c-146">Gdy wykres pakietu dla aplikacji zawiera różne wersje tego samego pakietu, NuGet wybiera pakiet, który jest najbardziej zbliżony do aplikacji na wykresie i ignoruje wszystkie pozostałe.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-146">When the package graph for an application contains different versions of the same package, NuGet chooses the package that's closest to the application in the graph and ignores all others.</span></span> <span data-ttu-id="a3d1c-147">To zachowanie umożliwia zastąpienie dowolnej wersji pakietu z określonego na wykresie zależności aplikacji.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-147">This behavior allows an application to override any particular package version in the dependency graph.</span></span>

<span data-ttu-id="a3d1c-148">W poniższym przykładzie jest zależna aplikacja, bezpośrednio na B pakietu z ograniczenie wersji > = 2.0.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-148">In the example below, the application depends directly on Package B with a version constraint of >=2.0.</span></span> <span data-ttu-id="a3d1c-149">Aplikacja zależy również od pakietu A, który z kolei również zależy od pakietu B, ale z > = 1.0 ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-149">The application also depends on Package A which in turn also depends on Package B, but with a >=1.0 constraint.</span></span> <span data-ttu-id="a3d1c-150">Zależność od pakietu B 2.0 jest względem aplikacji na wykresie, zostanie użyta ta wersja:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-150">Because the dependency on Package B 2.0 is nearer to the application in the graph, that version is used:</span></span>

![Aplikacji przy użyciu reguły najbliższej Wins](media/projectJson-dependency-5.png)

>[!Warning]
> <span data-ttu-id="a3d1c-152">Reguła najbliższej Wins może spowodować obniżenie wersji pakietu, w związku z tym potencjalnie fundamentalne innych zależności na wykresie.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-152">The Nearest Wins rule can result in a downgrade of the package version, thus potentially breaking other dependencies in the graph.</span></span> <span data-ttu-id="a3d1c-153">Dlatego ta reguła jest stosowana z ostrzeżeniem, aby ostrzec użytkownika.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-153">Hence this rule is applied with a warning to alert the user.</span></span>

<span data-ttu-id="a3d1c-154">Ta zasada powoduje również w większą wydajność o na wykresie zależności duże (takich jak z pakietami BCL) ponieważ po danym zależności jest ignorowana, NuGet również ignoruje wszystkie pozostałe zależności w oddziale wykresu.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-154">This rule also results in greater efficiency with a large dependency graph (such as those with the BCL packages) because once a given dependency is ignored, NuGet also ignores all remaining dependencies on that branch of the graph.</span></span> <span data-ttu-id="a3d1c-155">Na poniższym diagramie na przykład, ponieważ pakiet C 2.0 jest używana, NuGet ignoruje odgałęzień na wykresie, które odwołują się do starszej wersji pakietu c:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-155">In the diagram below, for example, because Package C 2.0 is used, NuGet ignores any branches in the graph that refer to an older version of Package C:</span></span>

![NuGet ignoruje pakietu na wykresie, ignoruje całą gałąź](media/projectJson-dependency-6.png)

<a name="cousin-dependencies"></a>

#### <a name="cousin-dependencies"></a><span data-ttu-id="a3d1c-157">Cousin zależności</span><span class="sxs-lookup"><span data-stu-id="a3d1c-157">Cousin dependencies</span></span>

<span data-ttu-id="a3d1c-158">W przypadku pakietu różne wersje są określane w tej samej odległości na wykresie z aplikacji, NuGet korzysta z Najniższa wersja, która spełnia wszystkie wymagania dotyczące wersji (jak [Najniższa wersja dotyczy](#lowest-applicable-version) i [ liczby zmiennoprzecinkowe wersji](#floating-versions) zasady).</span><span class="sxs-lookup"><span data-stu-id="a3d1c-158">When different package versions are referred to at the same distance in the graph from the application, NuGet uses the lowest version that satisfies all version requirements (as with the [lowest applicable version](#lowest-applicable-version) and [floating versions](#floating-versions) rules).</span></span> <span data-ttu-id="a3d1c-159">Na poniższej ilustracji, na przykład w wersji 2.0 z pakietu B spełnia innych > = 1.0 ograniczenia i jest używany w związku z tym:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-159">In the image below, for example, version 2.0 of Package B satisfies the other >=1.0 constraint, and is thus used:</span></span>

![Rozpoznawanie zależności cousin przy użyciu starszej wersji, która spełnia wszystkie ograniczenia](media/projectJson-dependency-7.png)

<span data-ttu-id="a3d1c-161">W niektórych przypadkach nie jest możliwe spełnia wszystkie wymagania dotyczące wersji.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-161">In some cases, it's not possible to meet all version requirements.</span></span> <span data-ttu-id="a3d1c-162">Jak pokazano poniżej, jeśli pakiet A wymaga dokładnie pakietu B 1.0, a pakiet C pakietu B > = 2.0, a następnie NuGet nie można rozpoznać zależności i zwraca błąd.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-162">As shown below, if Package A requires exactly Package B 1.0 and Package C requires Package B >=2.0, then NuGet cannot resolve the dependencies and gives an error.</span></span>

![Nierozpoznane zależności ze względu na to wymaganie dotyczące dokładnej wersji](media/projectJson-dependency-8.png)

<span data-ttu-id="a3d1c-164">W takich przypadkach najwyższego poziomu konsumenta (aplikacją lub pakietem) należy dodać bezpośrednie zależności pakietu B, aby [najbliższej Wins](#nearest-wins) reguła ma zastosowanie.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-164">In these situations, the top-level consumer (the application or package) should add its own direct dependency on Package B so that the [Nearest Wins](#nearest-wins) rule applies.</span></span>

## <a name="dependency-resolution-with-packagesconfig"></a><span data-ttu-id="a3d1c-165">Rozpoznawanie zależności z pliku packages.config</span><span class="sxs-lookup"><span data-stu-id="a3d1c-165">Dependency resolution with packages.config</span></span>

<span data-ttu-id="a3d1c-166">Z `packages.config`, zależności projektu są zapisywane w `packages.config` jako płaska lista.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-166">With `packages.config`, a project's dependencies are written to `packages.config` as a flat list.</span></span> <span data-ttu-id="a3d1c-167">Wszystkie zależności są pakiety również są zapisywane w tej samej listy.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-167">Any dependencies of those packages are also written in the same list.</span></span> <span data-ttu-id="a3d1c-168">Po zainstalowaniu pakietów NuGet może także modyfikować `.csproj` pliku `app.config`, `web.config`i inne poszczególnych plików.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-168">When packages are installed, NuGet might also modify the `.csproj` file, `app.config`, `web.config`, and other individual files.</span></span>

<span data-ttu-id="a3d1c-169">Z `packages.config`, próbuje rozwiązywania konfliktów zależności podczas instalacji każdego poszczególnych pakietu NuGet.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-169">With `packages.config`, NuGet attempts to resolve dependency conflicts during the installation of each individual package.</span></span> <span data-ttu-id="a3d1c-170">Oznacza to, że jeśli pakiet A jest instalowany i jest zależna od pakietu B i B pakietu jest już na liście `packages.config` jako zależność z innego elementu NuGet porównuje wersje pakietu B żądanej i próbuje odnaleźć wersji, która spełnia wszystkie wersji ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-170">That is, if Package A is being installed and depends on Package B, and Package B is already listed in `packages.config` as a dependency of something else, NuGet compares the versions of Package B being requested and attempts to find a version that satisfies all version constraints.</span></span> <span data-ttu-id="a3d1c-171">W szczególności NuGet wybierze niższą *major.minor* wersji, która spełnia zależności.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-171">Specifically, NuGet selects the lower *major.minor* version that satisfies dependencies.</span></span>

<span data-ttu-id="a3d1c-172">Domyślnie NuGet 2.7 i starszych jest rozpoznawana jako najwyższe *poprawki* wersji (za pomocą *major.minor.patch.build* Konwencji).</span><span class="sxs-lookup"><span data-stu-id="a3d1c-172">By default, NuGet 2.7 and earlier resolves the highest *patch* version (using the *major.minor.patch.build* convention).</span></span> <span data-ttu-id="a3d1c-173">[NuGet 2,8 i wyższych](../release-notes/nuget-2.8.md#patch-resolution-for-dependencies) zmienia to zachowanie, aby wyszukać Najniższa wersja poprawki domyślnie.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-173">[NuGet 2.8 and higher](../release-notes/nuget-2.8.md#patch-resolution-for-dependencies) changes this behavior to look for the lowest patch version by default.</span></span> <span data-ttu-id="a3d1c-174">Można kontrolować, to ustawienie za pomocą `DependencyVersion` atrybutu w `Nuget.Config` i `-DependencyVersion` przełącznik w wierszu polecenia.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-174">You can control this setting through the `DependencyVersion` attribute in `Nuget.Config` and the `-DependencyVersion` switch on the command line.</span></span>  

<span data-ttu-id="a3d1c-175">`packages.config` Przetworzyć dla rozpoznawania zależności pobiera skomplikowane dla większych wykresy zależności.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-175">The `packages.config` process for resolving dependencies gets complicated for larger dependency graphs.</span></span> <span data-ttu-id="a3d1c-176">Każda nowa instalacja pakietu wymaga przechodzenie całego grafu i zwiększa prawdopodobieństwo wystąpienia konfliktów wersji.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-176">Each new package installation requires a traversal of the whole graph and raises the chance for version conflicts.</span></span> <span data-ttu-id="a3d1c-177">Gdy wystąpi konflikt, instalacja zostanie zatrzymana, pozostawiając projektu w stanie nieokreślonym, szczególnie w przypadku potencjalnych zmiany w samym pliku projektu.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-177">When a conflict occurs, installation is stopped, leaving the project in an indeterminate state, especially with potential modifications to the project file itself.</span></span> <span data-ttu-id="a3d1c-178">To nie jest problem, korzystając z innych formatów odwołanie do pakietu.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-178">This is not an issue when using other package reference formats.</span></span>


## <a name="managing-dependency-assets"></a><span data-ttu-id="a3d1c-179">Zarządzanie zasobami zależności</span><span class="sxs-lookup"><span data-stu-id="a3d1c-179">Managing dependency assets</span></span>

<span data-ttu-id="a3d1c-180">Korzystając z `project.json` lub PackageReference formatów, można kontrolować, które zasoby z przepływu zależności w projekcie najwyższego poziomu.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-180">When using the `project.json` or PackageReference formats, you can control which assets from dependencies flow into the top-level project.</span></span> <span data-ttu-id="a3d1c-181">Aby uzyskać więcej informacji, zobacz [project.json](../Schema/project-json.md) i [pakietu odwołań w plikach projektu](Package-References-in-Project-Files.md#controlling-dependency-assets).</span><span class="sxs-lookup"><span data-stu-id="a3d1c-181">For details, see [project.json](../Schema/project-json.md) and [Package references in project files](Package-References-in-Project-Files.md#controlling-dependency-assets).</span></span>

<span data-ttu-id="a3d1c-182">Gdy najwyższego poziomu projektu jest pakietem, również mają kontrolę nad tym przepływu za pomocą `include` i `exclude` atrybutów na liście zależności `.nuspec` pliku.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-182">When the top-level project is itself a package, you also have control over this flow by using the `include` and `exclude` attributes with dependencies listed in the `.nuspec` file.</span></span> <span data-ttu-id="a3d1c-183">Zobacz [.nuspec — odwołanie do zależności](../Schema/nuspec.md#dependencies).</span><span class="sxs-lookup"><span data-stu-id="a3d1c-183">See [.nuspec Reference - Dependencies](../Schema/nuspec.md#dependencies).</span></span>

## <a name="excluding-references"></a><span data-ttu-id="a3d1c-184">Z wyjątkiem odwołania</span><span class="sxs-lookup"><span data-stu-id="a3d1c-184">Excluding references</span></span>

<span data-ttu-id="a3d1c-185">Istnieją scenariusze, w których zestawów o tej samej nazwie może być więcej niż jedno odwołanie w projekcie zwracające błędy czasu projektowania i czas kompilacji.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-185">There are scenarios in which assemblies with the same name might be referenced more than once in a project, producing design-time and build-time errors.</span></span> <span data-ttu-id="a3d1c-186">Należy wziąć pod uwagę projekt, który zawiera niestandardową wersję `C.dll`i odwołuje się C pakietu, który zawiera także `C.dll`.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-186">Consider a project that contains a custom version of `C.dll`, and references Package C that also contains `C.dll`.</span></span> <span data-ttu-id="a3d1c-187">W tym samym czasie, projekt zależy również od B pakietu, który również jest zależny od pakietu C i `C.dll`.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-187">At the same time, the project also depends on Package B which also depends on Package C and `C.dll`.</span></span> <span data-ttu-id="a3d1c-188">W związku z tym NuGet nie może określić, które `C.dll` do użycia, ale po prostu nie można usunąć zależności projektu C pakietu, ponieważ pakiet B również zależy od niego.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-188">As a result, NuGet can't determine which `C.dll` to use, but you can't just remove the project's dependency on Package C because Package B also depends on it.</span></span>

<span data-ttu-id="a3d1c-189">Aby rozwiązać ten problem, należy bezpośrednio odwoływać `C.dll` mają (lub użyj innego pakietu, który odwołuje się do właściwego), a następnie dodać zależność C pakietu, który wyklucza wszystkie jego zasoby.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-189">To resolve this, you must directly reference the `C.dll` you want (or use another package that references the right one), and then add a dependency on Package C that excludes all its assets.</span></span> <span data-ttu-id="a3d1c-190">W zależności od formatu używanego odwołanie do pakietu odbywa się w następujący sposób:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-190">This is done as follows depending on the package reference format in use:</span></span>

- <span data-ttu-id="a3d1c-191">[PackageReference](../consume-packages/package-references-in-project-files.md): Dodaj `Exclude="All"` w zależności:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-191">[PackageReference](../consume-packages/package-references-in-project-files.md): add `Exclude="All"` in the dependency:</span></span>

    ```xml
    <PackageReference Include="PackageC" Version="1.0.0" Exclude="All" />
    ```

- <span data-ttu-id="a3d1c-192">`packages.config`: Usuń odwołanie do PackageC z `.csproj` plików w celu odwołuje się tylko wersję `C.dll` żądany.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-192">`packages.config`: remove the reference to PackageC from the `.csproj` file so that it references only the version of `C.dll` that you want.</span></span>
    
- <span data-ttu-id="a3d1c-193">`project.json`: Dodaj `"exclude" : "all"` w zależność PackageC:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-193">`project.json`: add `"exclude" : "all"` in the dependency for PackageC:</span></span>

    ```json
    {
        "dependencies": {
            "PackageC": {
            "version": "1.0.0",
            "exclude": "all"
            }
        }
    }
    ```

## <a name="dependency-updates-during-package-install"></a><span data-ttu-id="a3d1c-194">Instalowanie aktualizacji zależności w pakiecie</span><span class="sxs-lookup"><span data-stu-id="a3d1c-194">Dependency updates during package install</span></span> 

<span data-ttu-id="a3d1c-195">Nuget 2.4.x i wcześniej, po zainstalowaniu pakietu zależności, których już istnieje w projekcie zależności zostanie zaktualizowana do najnowszej wersji spełniającego ograniczenia wersji, nawet jeśli istniejąca wersja także spełnia te ograniczenia.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-195">With NuGet 2.4.x and earlier, when a package is installed whose dependency already exists in the project, the dependency is updated to the latest version that satisfies the version constraints, even if the existing version also satisfies those constraints.</span></span> 

<span data-ttu-id="a3d1c-196">Rozważmy na przykład pakiet A jest zależny od pakietu B, który określa 1.0 numeru wersji.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-196">For example, consider package A that depends on package B and specifies 1.0 for the version number.</span></span> <span data-ttu-id="a3d1c-197">Repozytorium źródłowe zawiera zarówno wersji 1.0, 1.1 i 1.2 pakietu B. Jeśli A jest zainstalowany w projekcie, która zawiera już B w wersji 1.0, B zostało zaktualizowane do wersji 1.2.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-197">The source repository contains both versions 1.0, 1.1, and 1.2 of package B. If A is installed in a project that already contains B version 1.0, then B is updated to version 1.2.</span></span> 

<span data-ttu-id="a3d1c-198">Z NuGet 2.5 i później Jeśli spełniony jest już wersję zależności, zależność nie zostały zaktualizowane podczas inne instalacje pakietu.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-198">With NuGet 2.5 and later, if a dependency version is already satisfied, the dependency isn't updated during other package installations.</span></span> 

<span data-ttu-id="a3d1c-199">W tym samym przykładzie powyżej instalowania pakietu, który A do projektu z NuGet 2.5 i nowsze pozostawia pakiet B 1.0 w projekcie, ponieważ już spełnia ograniczenie wersji.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-199">In the same example above, installing package A into a project with NuGet 2.5 and later leaves package B 1.0 in the project, as it already satisfies the version constraint.</span></span> <span data-ttu-id="a3d1c-200">Jednak jeśli pakietu A były żądania w wersji 1.1 lub nowszej b, następnie B 1.2 będzie zainstalowany.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-200">However, if package A had requests version 1.1 or higher of B, then B 1.2 would be installed.</span></span> 

## <a name="resolving-incompatible-package-errors"></a><span data-ttu-id="a3d1c-201">Rozwiązywanie błędów niezgodne pakietu</span><span class="sxs-lookup"><span data-stu-id="a3d1c-201">Resolving incompatible package errors</span></span>

<span data-ttu-id="a3d1c-202">Podczas pakietu operację przywracania, może zostać wyświetlony błąd "co najmniej jednego pakietu nie są zgodne..." lub pakietu "nie jest zgodny" z platformy docelowej projektu.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-202">During a package restore operation, you may see the error "One or more packages are not compatible..." or that a package "is not compatible" with the project's target framework.</span></span>

<span data-ttu-id="a3d1c-203">Ten błąd występuje, gdy jeden lub więcej pakietów, do którego odwołuje się projekt nie wskazują obsługują platformy docelowej projektu; oznacza to, że pakiet nie zawiera odpowiedniej biblioteki DLL w jego `lib` folderu dla struktury docelowej, która jest zgodna z projektem.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-203">This error occurs when one or more of the packages referenced in your project do not indicate that they support the project's target framework; that is, the package does not contain a suitable DLL in its `lib` folder for a target framework that is compatible with the project.</span></span> <span data-ttu-id="a3d1c-204">(Zobacz [platform docelowych](../Schema/Target-Frameworks.md) listę.)</span><span class="sxs-lookup"><span data-stu-id="a3d1c-204">(See [Target frameworks](../Schema/Target-Frameworks.md) for a list.)</span></span> 

<span data-ttu-id="a3d1c-205">Na przykład, jeśli projekt przeznaczony `netstandard1.6` i spróbujesz zainstalować pakiet, który zawiera pliki DLL tylko `lib\net20` i `\lib\net45` foldery, możesz wyświetlone komunikaty podobnie do następującej dla pakietu i jego zależności:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-205">For example, if a project targets `netstandard1.6` and you attempt to install a package that contains DLLs in only the `lib\net20` and `\lib\net45` folders, then you'll see messages like the following for the package and possibly its dependents:</span></span>

```output
Restoring packages for myproject.csproj...
Package ContosoUtilities 2.1.2.3 is not compatible with netstandard1.6 (.NETStandard,Version=v1.6). Package ContosoUtilities 2.1.2.3 supports:
  - net20 (.NETFramework,Version=v2.0)
  - net45 (.NETFramework,Version=v4.5)
Package ContosoCore 0.86.0 is not compatible with netstandard1.6 (.NETStandard,Version=v1.6). Package ContosoCore 0.86.0 supports:
  - 11 (11,Version=v0.0)
  - net20 (.NETFramework,Version=v2.0)
  - sl3 (Silverlight,Version=v3.0)
  - sl4 (Silverlight,Version=v4.0)
One or more packages are incompatible with .NETStandard,Version=v1.6.
Package restore failed. Rolling back package changes for 'MyProject'.
```

<span data-ttu-id="a3d1c-206">Aby rozwiązać niezgodności, wykonaj jedną z następujących czynności:</span><span class="sxs-lookup"><span data-stu-id="a3d1c-206">To resolve incompatibilities, do one of the following:</span></span>

- <span data-ttu-id="a3d1c-207">Przekieruj z projektem, aby platforma, która jest obsługiwana przez pakiety, które chcesz użyć.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-207">Retarget your project to a framework that is supported by the packages you want to use.</span></span>
- <span data-ttu-id="a3d1c-208">Skontaktuj się z autorem pakietów i pracować z nimi, aby dodać obsługę z wybranym framework.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-208">Contact the author of the packages and work with them to add support for your chosen framework.</span></span> <span data-ttu-id="a3d1c-209">Każdy pakiet wyświetlania strony na [nuget.org](https://www.nuget.org/) ma **właścicieli skontaktuj się z** łącza do tego celu.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-209">Each package listing page on [nuget.org](https://www.nuget.org/) has a **Contact Owners** link for this purpose.</span></span>
- <span data-ttu-id="a3d1c-210">**Nie zaleca się**: jako rozwiązanie tymczasowe podczas pracy z autorem pakietu, projektów przeznaczonych dla `netcore`, `netstandard`, i `netcoreapp` są oznaczane innych platform, jako niezgodna, umożliwiając pakietów przeznaczonych dla tych innych platform, które mają być używane.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-210">**Not recommended**: as a temporary solution while you work with the package author, projects targeting `netcore`, `netstandard`, and `netcoreapp` can denote other frameworks as being compatible, thereby allowing packages targeting those other frameworks to be used.</span></span> <span data-ttu-id="a3d1c-211">Zobacz [importuje project.json](../Schema/project-json.md#imports) i [docelowy programu MSBuild przywracania PackageTargetFallback](../Schema/msbuild-targets.md#packagetargetfallback).</span><span class="sxs-lookup"><span data-stu-id="a3d1c-211">See [project.json imports](../Schema/project-json.md#imports) and [MSBuild restore target PackageTargetFallback](../Schema/msbuild-targets.md#packagetargetfallback).</span></span> <span data-ttu-id="a3d1c-212">Może to spowodować nieoczekiwane wyniki, więc ponownie najlepiej rozwiązać niezgodności pakietu przy pracy z autorem pakietu podczas aktualizacji.</span><span class="sxs-lookup"><span data-stu-id="a3d1c-212">This can cause unexpected behaviors, so again, it's best to resolve package incompatibilities by working with the package author on an update.</span></span>
